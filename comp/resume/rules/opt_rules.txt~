プロセッサ実験学期末コンテストルール

１．ソースとの同一性および再現性

・自分達が実装した浮動小数点演算プリミティブを用いて、元のocamlソースをocamlの
  言語モデルに従って実行する事を以下では非最適化実行と呼ぶ。コンテストで使用す
  るコードは(1)全てのSLDファイルに対して非最適化実行の際と完全に同一(1ビットも
  違わない)な画像を生成せねばならなず、かつ(2)非最適化実行の場合と同一オペラン
  ドの浮動小数点演算が同一回数行われなければならない。ただし、(2)については定数
  割り算最適化(後述)、冗長性除去、定数畳み込みは例外とする。

・同一内容のSLDファイルに対しては毎回同じ画像が出力されねばならない

２．競技成績の評価方法

・各班は競技に使用するコードとして以下の両方を用意する。完動しないものは不可。

  (1)コンパイラが出力したコード(以下、コンパイラコードと呼ぶ)
  (2)生成方法に関わらず、１．を満たすコード(以下、フリーコードと呼ぶ)

  このそれぞれについて記録が測定される。競技の制限時間は各900秒(15分)とする。

  コンパイラコードが満たす詳細な条件は後述する。フリーコードは、コンパイラに人
  手でヒントを与えて出力したり、ハンドコンパイルしたりして生成したコードなどが
  該当する。なおフリーコードはコンパイラコードを含む点に注意。つまり、コンパイ
  ラコードだけで勝負する事も可能である(例年こうする班が圧倒的多数)。
  この場合はコンパイラコードの記録が(1)と(2)両方の記録となる。計測は一回しか行
  わない。

・順位の付け方

  (1)と(2)の記録の合計値により順位を付ける(値が小さいほど順位高)。
    
３．コンパイラコードの条件
・出力コードは１．を満たすこと
・入力するocamlのソースのうちmin-rt.mlは以下の点を除いて変更してはならない

  (1)関数tanとxorを自前のライブラリまたはコンパイラの組み込み関数で置き換える
  (2)出力画像のバイナリ化のために write_ppm_header、write_rgb_element、
     write_rgb の各関数を変更する。
  (3)定数 true と false の定義方法をコンパイラ仕様に合わせて変更・削除する

  ※他に変更が必要と考えられる場合は相談すること

  なお、入力SLDのバイナリ化を行うには read_intとread_floatの各ライブラリ関数の
  実装を変更すれば良い。
・globals.mlは現在プロセッサ実験で教えるコンパイラではコンパイルが難しいので、特別にソ
  ース変更やハンドコンパイルを認める。もちろん、ソースの意味は変更してはならな
  い。
・不正ベンチマーク事件(*1)に使用された某社のコンパイラのように、レイトレのソー
  スが入力された場合だけハンドコンパイルされたコードを出力する等の処理は不可。
  その他、一般的な計算機のコンパイラとして不適切な処理は行わないこと。

  (*1)あらかじめ登録されたベンチマークのソースファイルが入力された場合だけ特別
      なルーチンが起動し、ハンドコンパイルされた非常に高速なコードが出力される
      という仕掛けが某社のコンパイラに組み込まれていたという事件。ヘネシー＆パ
      ターソン本を参照。

４．プロセッサ実験では特別に許されるソフトウェア最適化

・定数の割り算を、逆数の掛け算に直しても良い(例：X/5 -> X*0.2)

  最適化しない場合とした場合で、自分達の浮動小数点演算プリミティブを用いた場合
  に、Xが -2^127 < X < 2^127を満たす有効な浮動小数点(*2)なら演算結果が完全一致
  する(1ビットも違っていない)、という条件を満たせば許可する。

  (*2)浮動小数点演算プリミティブの実装基準を参照

５．プロセッサ実験では特別に許されるハードウェア最適化

・初期化データをFPGA内のメモリに置くために、VHDLのattributeや.UCFファイルでメモ
  リの初期値を指定しても良い

